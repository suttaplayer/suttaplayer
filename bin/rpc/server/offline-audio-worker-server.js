"use strict";(()=>{var d=class n{static async getFromCache(e,s){let r=[];if(!caches)return r;let t=await caches.open(e);for(let o=0;o<s.length;o++){let a=await t.match(s[o]);r.push(a)}return r}static async isInCache(e,s,r){let t=[];if(!caches)return t;let o=await n.getFromCache(e,s);for(let a=0;a<s.length;a++){let i=!!o[a]?.ok;!i&&r&&(i=r(o[a],s[a])),t.push(i)}return t}static async addCachedUrls(e,s){let r=[];if(!caches)return r;let t=await caches.open(e);for(let o=0;o<s.length;o++){let a=!1;try{s[o]&&(await t.add(s[o]),a=!0)}catch{}r.push(a)}return r}static async deleteCachedUrls(e,s,r){let t=[];if(!caches)return t;let o=await caches.open(e);for(let a=0;a<s.length;a++){let i=await o.delete(s[a],r);t.push(i)}return t}};var l="dhamma-initiative.github.io",_=`https://${l}`;var u=class{static queryTrackTextUrl(e){return`${_}/${e}.txt`}static queryTrackHtmlAudioSrcRef(e){return`${_}/${e}.wav.mp3`}static parseTrackRefElements(e){let s=e.replace(/^.*[\\\/]/,""),r=e.substring(0,e.length-s.length);return r.startsWith("/")&&(r=r.substring(1)),r.endsWith("/")&&(r=r.substring(0,r.length-1)),[r,s]}static jsonToQueryString(e,s){let r=new URLSearchParams;return Object.getOwnPropertyNames(e).forEach((a,i,b)=>{e[a]!==void 0&&(!s||s&&s[a]!==e[a])&&r.set(a,e[a])}),r.toString().replaceAll("%2C",",")}static getSearchParamValueAsFloat(e,s){let r=parseFloat(e);return isNaN(r)?s:r}};var c=class{static async isAudioInCache(e){let s=u.queryTrackHtmlAudioSrcRef(e);return await d.isInCache(l,[s],(t,o)=>t?.type==="opaque"&&t?.url==="")}static async addAudioToCache(e){let s=u.queryTrackHtmlAudioSrcRef(e);return await d.addCachedUrls(l,[s])}static async removeAudioFromCache(e){let s=u.queryTrackHtmlAudioSrcRef(e);return await d.deleteCachedUrls(l,[s])}};var g=class{static defer(){let e,s,r=new Promise((o,a)=>{e=o,s=a}),t=r;return t.resolve=e,t.reject=s,r}};var p=class n{static THREAD_TYPES=["Window","DedicatedWorkerGlobalScope","ServiceWorkerGlobalScope","SharedWorkerGlobalScope"];static THREAD_TYPE=self.constructor.name;static THREAD_TYPE_IDX=n.THREAD_TYPES.indexOf(n.THREAD_TYPE);static THREAD_ID;static IS_MOBILE_PLATFORM;static _debounceTimer;static deepClone(e){if(e===null||typeof e!="object")return e;if(Array.isArray(e))return e.map(r=>n.deepClone(r));let s={};for(let r in e)e.hasOwnProperty(r)&&(s[r]=n.deepClone(e[r]));return s}static debounce(e,s){clearTimeout(n._debounceTimer),n._debounceTimer=setTimeout(e,s)}static _setIsMobilePlatform(){if(n.IS_MOBILE_PLATFORM!==void 0)return;let e=navigator.userAgent.match(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i),s="ontouchstart"in(n.THREAD_TYPE_IDX===0?window:self),r="accelerometer"in(n.THREAD_TYPE_IDX===0?window:self);n.IS_MOBILE_PLATFORM=!!(e||s||r),console.log(`Thread#[${n.THREAD_TYPE_IDX}].IS_MOBILE=${n.IS_MOBILE_PLATFORM}`)}static _setThreadId(){if(n.THREAD_TYPE_IDX===0)n.THREAD_ID=n.THREAD_TYPE;else if(n.THREAD_TYPE_IDX===2){let e="/indeterminant-scriptURL";"serviceWorker"in self&&"scriptURL"in self.serviceWorker&&(e=self.serviceWorker.scriptURL),n.THREAD_ID=`sw${e.substring(e.lastIndexOf("/"))}`}else if(n.THREAD_ID=self.name,!n.THREAD_ID)throw new Error("IllegalState: All web workers & shared workers must be named via the constructor!")}static{n._setThreadId(),n._setIsMobilePlatform()}};var h=class n{static _resolvedPromise=Promise.resolve(void 0);static _promiseHashMap=new Map;api=NaN;_rpcIdxFuncMap=new Map;_rpcFuncIdxMap=new Map;_orderedTransferredPortMaps=[];_namedTransferredPortMaps=new Map;bindRpcFunc(e,s,r){let t=this._rpcIdxFuncMap.size;this._rpcIdxFuncMap.set(t,{thisArg:e,run:s,...r}),this._rpcFuncIdxMap.set(s,t)}_prepareMessage(e,s){let r={headers:{request:{id:p.THREAD_ID,context:this.__getName__(),portId:"<required>"}},api:this.api,rpc:this._rpcFuncIdxMap.get(e)};if(Number.isNaN(r.api)||r.rpc===void 0)throw new Error(`IllegalArgument: [${JSON.stringify(r)}]; indeterminate API/RPC target!`);let t=this._rpcIdxFuncMap.get(r.rpc);if(!t.hasNoArgs){if(s===void 0)throw new Error(`IllegalArgument: [${JSON.stringify(r)}] requires argument to be set before post!`);r.args=s}return t.hasReturn&&(r.returnPromise=!0),r}_bindMethods(e=!0){this._rpcIdxFuncMap.clear(),this._rpcFuncIdxMap.clear(),e&&this._bindSystemFuncs()}_bindSystemFuncs(){this.bindRpcFunc(this,this.__teardown__,{hasNoArgs:!0}),this.bindRpcFunc(this,this.__transferPorts__,{hasReturn:!0,hasServerTransferredPorts:!0}),this.bindRpcFunc(this,this.__getTransferredPorts__,{hasReturn:!0}),this.bindRpcFunc(this,this.__deleteTransferredPorts__)}async _handleRpc(e){if(e.data?.api!==this.api||e.data?.rpc===void 0||this._returnRpcResultIfResolved(e))return;this._registerTransferredPorts(e);let s=this._rpcIdxFuncMap.get(e.data.rpc);if(e.rpcInvoked=s,s)await this._invokeRpcMethod(e);else throw new Error(`IllegalArgument: rpc[${e.data.rpc}] not supported on Context[${this.__getName__()}]`)}_returnRpcResultIfResolved(e){let s=!1,r=e.data.promiseHash;if(r){let t=n._promiseHashMap.get(r);if(t)e.data.promiseHash=void 0,n._promiseHashMap.delete(r),t.resolve(e.data),s=!0;else if(e.data.resp)throw new Error(`IllegalState: ${p.THREAD_ID} received misdirected promiseHash[${r}]`)}return s}_registerTransferredPorts(e){for(let s=0;s<e.ports.length;s++)this._orderedTransferredPortMaps.push(e.ports[s]),e.ports[s].onmessage=async r=>{await this._onMessageChannelMessage(r)},e.ports[s].rpcPortId="altWorkerMC"}_unregisterTransferredPort(e){let s=this._orderedTransferredPortMaps.indexOf(e);s>-1&&(e.close(),e.onmessage=null,this._orderedTransferredPortMaps.splice(s,1))}async _invokeRpcMethod(e){let s=e.rpcInvoked,r=e.target||self,t=s.hasClientPromiseAwait?g.defer():void 0,o=[];s.hasNoArgs||o.push(e.data.args),s.hasClientPromiseAwait&&o.push(t),s.hasServerTransferredPorts&&o.push(e.ports),s.hasMessageEvent&&o.push(e),o.push(r);let a;if(s.thisArg?(s.runBound===void 0&&(s.runBound=s.run.bind(s.thisArg)),a=await s.runBound(...o)):a=await s.run(...o),t&&(a=await t),s.hasReturn){let i={...e.data,resp:a};i.headers.response={id:p.THREAD_ID,context:this.__getName__(),portId:r.rpcPortId},r.postMessage(i)}}_postMessage(e,s,r){let t=this._preparePostMessageReturnPromise(s);return r=this._preparePostMessageOptions(r),s.headers.request.portId=e.rpcPortId,e.postMessage(s,r),this._alertMessageDispatched(),t}_preparePostMessageReturnPromise(e){let s=n._resolvedPromise;return e.returnPromise&&(e.promiseHash=crypto.randomUUID(),e.returnPromise=void 0,s=g.defer(),n._promiseHashMap.set(e.promiseHash,s)),s}_preparePostMessageOptions(e){return e}_alertMessageDispatched(){}};var m=class extends h{_multiWorkerHandler;async __teardown__(){let e=arguments[0];if(e instanceof MessagePort&&this._unregisterTransferredPort(e),p.THREAD_TYPE_IDX===1&&"close"in e){let s=e;s.onmessage=null,s.close()}}async __transferPorts__(e,s){let r=s.length-e.portIds.length,t=0;for(let o=0;o<s.length;o++){let a=s[o];o>=r&&(this._namedTransferredPortMaps.set(e.portIds[o-r],a),a.rpcPortId=e.portIds[o-r]),t++}return{count:t}}async __getTransferredPorts__(){return{portIds:Array.from(this._namedTransferredPortMaps.keys())}}async __deleteTransferredPorts__(e){e.portIds.forEach((s,r,t)=>{let o=this._namedTransferredPortMaps.get(s);this._unregisterTransferredPort(o),this._namedTransferredPortMaps.delete(s)})}startServer(e="message"){console.log(`${p.THREAD_ID}>${this.__getName__()}[v${this.__getVersion__()}] started: waiting for messages...`),this._multiWorkerHandler=async s=>{if(e==="connect"&&!s.data){s.ports[0].onmessage=this._multiWorkerHandler,s.ports[0].rpcPortId="DEFAULT";return}await this._handleRpc(s)},e==="connect"&&"onconnect"in self?(self.onconnect=this._multiWorkerHandler,self.rpcPortId="DEFAULT"):e==="message"&&"onmessage"in self&&(self.onmessage=this._multiWorkerHandler,self.rpcPortId="DEFAULT"),this._bindMethods()}async _onMessageChannelMessage(e){await this._multiWorkerHandler(e)}};var f=class{static bindRpc(e){let s=e;s.api||(s.api=2),s.bindRpcFunc(s,e.downloadTrack,{hasReturn:!0}),s.bindRpcFunc(s,e.deleteTrack,{hasReturn:!0}),s.bindRpcFunc(s,e.onProcessed)}};var R=class n extends m{static VERSION="2.0.0";__getVersion__(){return n.VERSION}__getName__(){return"OfflineAudioWorkerServer"}onProcessed=async e=>{let s=this._prepareMessage(this.onProcessed,e);await this._postMessage(self,s,void 0)};async downloadTrack(e){let s=await c.isAudioInCache(e.trackRef);return s[0]||(await c.addAudioToCache(e.trackRef),s=await c.isAudioInCache(e.trackRef),s[0]&&await this.onProcessed({...e,isInCache:s[0]})),{...e,isInCache:s[0]}}async deleteTrack(e){let s=await c.isAudioInCache(e.trackRef);return s[0]&&(await c.removeAudioFromCache(e.trackRef),s=await c.isAudioInCache(e.trackRef),s[0]||await this.onProcessed({...e,isInCache:s[0]})),{...e,isInCache:s[0]}}_bindMethods(){super._bindMethods(),f.bindRpc(this)}},P=new R;P.startServer();})();
